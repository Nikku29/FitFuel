import { getExerciseTag } from '@/data/exerciseTags';

interface VisualAsset {
    id: string;
    exerciseName: string;
    category?: string;
    urls: {
        start: string;
        mid?: string;
        end: string;
    };
    source: 'local' | 'firestore' | 'generated';
}

const LOCAL_ASSET_MAP: Record<string, any> = {
    // Basic Bodyweight (Hardcoded for latency)
    'push-up': {
        start: 'https://cdn-icons-png.flaticon.com/512/2548/2548537.png',
        end: 'https://cdn-icons-png.flaticon.com/512/2548/2548530.png'
    },
    'bodyweight squat': {
        start: 'https://cdn-icons-png.flaticon.com/512/3048/3048347.png',
        end: 'https://cdn-icons-png.flaticon.com/512/3048/3048356.png'
    },
    'plank': {
        start: 'https://cdn-icons-png.flaticon.com/512/2548/2548455.png',
        end: 'https://cdn-icons-png.flaticon.com/512/2548/2548455.png' // Static
    },
    'russian twist': {
        start: 'https://cdn-icons-png.flaticon.com/512/2548/2548545.png',
        end: 'https://cdn-icons-png.flaticon.com/512/2548/2548545.png' // Twist logic
    },
    // Fallbacks
    'default': {
        start: 'https://cdn-icons-png.flaticon.com/512/2964/2964514.png', // Generic fitness icon
        end: 'https://cdn-icons-png.flaticon.com/512/2964/2964514.png'
    }
};

class VisualAssetService {
    private cache: Map<string, VisualAsset> = new Map();

    constructor() {
        // Load from local storage if resilient
        try {
            const saved = localStorage.getItem('fitfuel_asset_cache');
            if (saved) {
                const parsed = JSON.parse(saved);
                Object.values(parsed).forEach((asset: any) => this.cache.set(asset.exerciseName.toLowerCase(), asset));
            }
        } catch (e) {
            console.warn("Failed to load asset cache", e);
        }
    }

    async getAssetForExercise(exerciseName: string, category: string = 'general'): Promise<VisualAsset> {
        const normalized = exerciseName.toLowerCase().trim();

        // 1. Check Memory Cache
        if (this.cache.has(normalized)) return this.cache.get(normalized)!;

        // 2. Check Local Map (Fastest)
        const localMatch = this.findInLocalMap(normalized);
        if (localMatch) {
            const asset: VisualAsset = {
                id: `local-${normalized}`,
                exerciseName,
                category,
                urls: localMatch,
                source: 'local'
            };
            this.addToCache(normalized, asset);
            return asset;
        }

        // 3. Fallback (Future: Add Firestore lookup here)
        // For now, return generic
        console.log(`VisualAsset: No asset found for ${exerciseName}, using fallback.`);
        return this.getFallbackAsset(exerciseName);
    }

    private findInLocalMap(name: string): any | null {
        // Direct match
        if (LOCAL_ASSET_MAP[name]) return LOCAL_ASSET_MAP[name];

        // Partial match (e.g., "db bench press" -> matches "bench press" logic if we had it, or specific keywords)
        // Simple keyword check for demo
        if (name.includes('squat')) return LOCAL_ASSET_MAP['bodyweight squat'];
        if (name.includes('push') || name.includes('press')) return LOCAL_ASSET_MAP['push-up']; // Crude fallback for demo

        return null;
    }

    private getFallbackAsset(name: string): VisualAsset {
        const tag = getExerciseTag(name);

        // Strict Fallback Rule:
        // 1. Check Specific Name (already failed if we are here)
        // 2. Check Base Movement (e.g., 'Side Plank' -> 'Plank')
        if (tag.base_movement && LOCAL_ASSET_MAP[tag.base_movement]) {
            return {
                id: `fallback-base-${tag.base_movement}`,
                exerciseName: name,
                urls: LOCAL_ASSET_MAP[tag.base_movement], // Use safe base asset
                source: 'local'
            };
        }

        // 3. Fallback to Procedural Pose based on tag
        if (tag.pose) {
            return {
                id: `procedural-${tag.pose}`,
                exerciseName: name,
                urls: {
                    start: 'procedural:start',
                    mid: 'procedural:mid',
                    end: 'procedural:end'
                },
                source: 'generated' // Treated as generated by the procedural engine
            };
        }

        // 4. Ultimate Fail-safe
        return {
            id: 'fallback-generic',
            exerciseName: name,
            urls: LOCAL_ASSET_MAP['default'],
            source: 'local'
        };
    }

    private generateThinkingPrompt(name: string): string {
        const tag = getExerciseTag(name);
        return `Create a technical instructional sprite sheet for $$${name}$$.
Composition: Single wide image containing 3 panels (Left to Right):
1. Start Position. 2. Mid-Point/Action. 3. End Position.
Constraints:
Equipment: $$${tag.equipment === 'none' ? 'NO Equipment' : tag.equipment.toUpperCase()}$$.
View: $$${tag.view.toUpperCase()}$$.
Negative Prompt: DO NOT show muscle anatomy, veins, or 3D rendering. DO NOT show text.
Style: Minimalist black line art on white background. No shading.
Text: None.`;
    }

    private addToCache(key: string, asset: VisualAsset) {
        this.cache.set(key, asset);
        // Persist to local storage for offline resilience
        try {
            const currentObj: any = {};
            this.cache.forEach((v, k) => currentObj[k] = v);
            localStorage.setItem('fitfuel_asset_cache', JSON.stringify(currentObj));
        } catch (e) {
            console.warn("Cache quota exceeded");
        }
    }

    async cacheSessionAssets(exercises: any[]) {
        console.log("Pre-caching assets for session...");
        const promises = exercises.map(ex => this.getAssetForExercise(ex.name, ex.category));
        await Promise.all(promises);
        console.log("Session assets cached.");
    }
}

export const visualAssetService = new VisualAssetService();
